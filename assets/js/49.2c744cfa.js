(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{335:function(t,a,e){"use strict";e.r(a);var s=e(14),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"js中的ecstack、ec、vo-和-ao"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js中的ecstack、ec、vo-和-ao"}},[t._v("#")]),t._v(" JS中的ECStack、EC、VO 和 AO")]),t._v(" "),a("p",[t._v("浏览器会在计算机内存中分配一块内存，专门用来供代码执行的栈内存，称作执行环境栈 (ECStack) 同时会创建一个 全局对象(GO)，将内置的属性方法( isNaN、setInterval、setTimeout... )存放到一块单独的堆内存空间，并且使用 window 指向全局对象。")]),t._v(" "),a("p",[t._v("在执行代码前，还需要创建一个全局执行上下文( EC(G) ), 创建完成后，进入到栈内存中去执行( 进栈)； 在当前全局执行上下文中，因为会创建很多变量并且赋值，所以会创建一个变量对象 VO(Varibale Object) 来进行保存，在函数私有上下文中的变量对象叫做 活动对象 AO(Activation Object) （ps: 每个执行上下文都有一个单独的变量对象）")]),t._v(" "),a("h3",{attrs:{id:"名称解释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#名称解释"}},[t._v("#")]),t._v(" 名称解释")]),t._v(" "),a("h4",{attrs:{id:"执行环境栈-ecstack-专门用来供代码执行的-栈内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行环境栈-ecstack-专门用来供代码执行的-栈内存"}},[t._v("#")]),t._v(" 执行环境栈(ECStack)：专门用来供代码执行的 栈内存")]),t._v(" "),a("h4",{attrs:{id:"全局对象-go-存放内置的属性方法-window-指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局对象-go-存放内置的属性方法-window-指向"}},[t._v("#")]),t._v(" 全局对象(GO)：存放内置的属性方法，window 指向")]),t._v(" "),a("h4",{attrs:{id:"全局执行上下文-ec-g-页面加载后进栈、销毁后出栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局执行上下文-ec-g-页面加载后进栈、销毁后出栈"}},[t._v("#")]),t._v(" 全局执行上下文( EC(G) )：页面加载后进栈、销毁后出栈")]),t._v(" "),a("h4",{attrs:{id:"变量对象vo-variable-object-存放当前执行上下文中创建的变量和值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量对象vo-variable-object-存放当前执行上下文中创建的变量和值"}},[t._v("#")]),t._v(" 变量对象VO(Variable Object)： 存放当前执行上下文中创建的变量和值")]),t._v(" "),a("h4",{attrs:{id:"活动对象ao-activation-object-函数私有上下文中的变量对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#活动对象ao-activation-object-函数私有上下文中的变量对象"}},[t._v("#")]),t._v(" 活动对象AO(Activation Object)： 函数私有上下文中的变量对象")]),t._v(" "),a("blockquote",[a("p",[t._v("AO是一个临时的储存容器，函数执行完毕之后，AO会自动销毁的（但是有一种情况例外，那就是闭包）不过闭包会导致内存泄漏。解决内存泄漏，其实很简单，函数执行完毕后在下面设置函数为null比如，foo=null，这样就解决了内存泄漏的问题")])])])}),[],!1,null,null,null);a.default=r.exports}}]);