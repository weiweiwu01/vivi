(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{322:function(t,s,a){"use strict";a.r(s);var r=a(14),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"最长递增子序列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最长递增子序列"}},[t._v("#")]),t._v(" 最长递增子序列")]),t._v(" "),s("p",[s("strong",[t._v("leetcode地址：")]),t._v(" "),s("a",{attrs:{href:"https://leetcode.cn/problems/longest-increasing-subsequence/description/"}},[t._v("最长递增子序列")])]),t._v(" "),s("p",[t._v("给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。")]),t._v(" "),s("p",[s("strong",[t._v("示例 1：")])]),t._v(" "),s("p",[t._v("输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。")]),t._v(" "),s("p",[s("strong",[t._v("示例 2：")])]),t._v(" "),s("p",[t._v("输入：nums = [0,1,0,3,2,3]\n输出：4")]),t._v(" "),s("p",[s("strong",[t._v("示例 3：")])]),t._v(" "),s("p",[t._v("输入：nums = [7,7,7,7,7,7,7]\n输出：1")]),t._v(" "),s("h2",{attrs:{id:"动态规划"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[t._v("#")]),t._v(" 动态规划")]),t._v(" "),s("h2",{attrs:{id:"二分查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二分查找"}},[t._v("#")]),t._v(" 二分查找")]),t._v(" "),s("h2",{attrs:{id:"贪心算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[t._v("#")]),t._v(" 贪心算法")]),t._v(" "),s("h2",{attrs:{id:"回溯修正"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯修正"}},[t._v("#")]),t._v(" 回溯修正")]),t._v(" "),s("p",[t._v("构造一个反向链表，每个节点记录上一个节点位置，最后回溯修正")])])}),[],!1,null,null,null);s.default=e.exports}}]);